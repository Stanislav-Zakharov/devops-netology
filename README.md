### 1. Какого типа команда cd?
> Команда **cd** является встроенной командой интерпритатора bash, которая изменяет текущую директорию 
> в контексте  текущей сессии командной оболочки. Не является исполняемым файлом. Не уверен, что она 
> могла бы быть другого типа, скажем исполняемым файлом и при этом иметь возможность управлять 
> контекстом оболочки.
### 2. Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l?
    grep "$" file.txt -c
### 3. Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?
    vagrant@vagrant:~$ ps 1
    PID TTY      STAT   TIME COMMAND
      1 ?        Ss     0:15 /sbin/init
### 4. Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?
    ls some_directory 2>/dev/pts/2
### 5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл?
    cat < src.txt > dst.txt
### 6. Получится ли находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY?
> Если подключиться непосредственно к эмулятору терминала **tty**, в нашем случае открыть через графический
> интерфейс VirtualBox, тем самым иммитировав "физическое подключение к машине", при наличии нужных 
> привилегий на /dev/tty? (или под root) можно направить вывод из pty в соответствующий /dev/tty? 
> и в реальном времени наблюдать этот вывод в подключенном эмуляторе терминала tty. (Проверено)
### 7. Выполните команду bash 5>&1
> *bash 5>&1* - откроет новый процесс bash в котором создаст дескриптор 5 и перенаправит его в stdout.  
> *echo netology > /proc/$$/fd/5* - выведет netology в stdout, так как дескриптор 5 - перенаправлен 
> на stdout
### 8. Получится ли в качестве входного потока для pipe использовать только stderr команды?
    ls not_existing_dir 3>&1 1>&2 2>&3 | cat
### 9. Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?
> *cat /proc/$$/environ* - выводит переменные окружения текущего процесса bash  
> Аналогично переменные среды текущего процесса bash можно получить через - *ps e $$*
### 10. Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe.
>* */proc/<PID>/cmdline* - содержит полную командную строку, с который был запущен процесс, пока он не
> превратился в зомби-процесс
> * */proc/<PID>/exe* - В Linux 2.2 и выше данный файл является символической ссылкой на исполняемый файл
> процесса, мы можем выполнить данный файл, для того чтобы запустить еще одну копию нашего процесса
### 11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор 
с помощью /proc/cpuinfo.
> *cat /proc/cpuinfo | grep " sse"*  
> SSE4.2
### 12. При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty
> Однако выполняя ssh с аргументом выполняемой удаленно командой, эмулятор терминала - не инициализируется,
> в связи с чем выполняя ***ssh localhost 'tty'*** мы получаем ***not a tty***.  
> Вопрос решается параметром ***-t***, который принудительно инициализирует ***tty***
> > ssh -t localhost 'tty'
### 13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. 
> В конфиге **/etc/sysctl.d/10-ptrace.conf** установил **kernel.yama.ptrace_scope = 0**, так как 
> по-умолчанию разрешено присоединять исключительно прямой дочерний процесс.  
> * В первом терминале запустил **vim**
> * Во втором запустил **screen**  
>    *  reptyr $VIM_PID
### 14. Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.
> **tee** читает stdin и пишет в stdout и в файл  
> **echo string | sudo tee /root/new_file** - в данной конструкции:
> * **tee** выполняется с повышенными привилегиями, поэтому имеет возможность записать в **/root/***
> * В **stdin** получает строку через **pipe**
> * Выводит полученные данные в **stdout**
> * Пишет в файл, указанный в аргументе при ее вызове